.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clone::Fast 3pm"
.TH Clone::Fast 3pm "2007-08-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Clone::Fast \- Natively copying Perl data structures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use strict;
\&        use warnings;
\&
\&        use Clone::Fast qw( clone );
\&        use Data::Dumper;
\&
\&        # Though that may be the easiest thing to do, there
\&        # are also other options:
\&        #
\&        # use Clone::Fast; # While using Clone::Fast::clone
\&        # {
\&        #   no strict \*(Aqrefs\*(Aq;
\&        #   *clone = \e&Clone::Fast::clone;
\&        # }
\&        #
\&        # eval( "sub clone { Clone::Fast::clone }" );
\&
\&        my $original = bless( { \*(Aqa\*(Aq => [ qw( a b c d ) ] }, \*(Aqmain\*(Aq );
\&        my $copy     = clone( $original );
\&
\&        # Notice the original and copy are no longer the same,
\&        # although they look exactly the same
\&        print "Different memory segments\en" if ( $original ne $copy );
\&        print "Same structure\en" if ( Dumper( $original ) eq Dumper( $copy ) );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Essentially, this module is a very optimized version of Clone::More.  By taking
advantage of one of Clone::More's '\s-1OPTIMIZATION_HACKS\s0' as well as removing all
the Pure Perl from the \f(CW\*(C`More.pm\*(C'\fR, I was able to gain a lot of speed out of the module.
Essentially, though, the core of the module is exactly as that of Clone::More.
.PP
You will see that by useing Benchmark::cmpthese, I ran a simple comparison between
Storable::dclone, Clone::More::clone, and Clone::Fast::clone.  You will (should)
begin to see the reason why I loaded this module along side of Clone::More.
.PP
.Vb 4
\&                                   Rate    Storable Clone::More Clone::Fast
\&        Storable     7552/s          \-\-        \-39%        \-59%
\&        Clone::More 12400/s         64%          \-\-        \-33%
\&        Clone::Fast 18442/s        144%         49%          \-\-
.Ve
.PP
For more information relative to the \s-1DESCRIPTION\s0 of this module, I recommend peeking into
the \s-1POD\s0 written for Clone::More (I took more time with it ;) )
.SS "\s-1HISTORY\s0"
.IX Subsection "HISTORY"
As noted in Clone::More, this module started as a patch for Clone with repsect to a
large memory leak a team I was working closely with at the time fell across once implemented
the cloning into a Perl application.  The unfortunate part is that I wasn't able to patch the
Clone module without a complete re-factor (I still have no idea where the leak is in Clone),
and have not been able to get ahold of Ray Finch, the current author and supporter of Clone.
Every thing considered, I loaded up this and it's counter part Clone::More \- both a little
different from one another, and both a little different from Clone still.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
\fIclone\fR
.IX Subsection "clone"
.PP
Clone is the primary function from within the provided module.  By passing a scalar reference to this
routine, you will expect to get a returned scalar reference that will no longer have any reference to
the originating reference.  However, references deeper into the structure will still uphold the references
within the structure.
.PP
Example being:
.PP
.Vb 1
\&        use Clone::Fast qw( clone );
\&
\&        my $foo = { \*(Aqa\*(Aq => \*(Aqb\*(Aq };
\&        my $bar = { \*(Aqa\*(Aq => $foo, \*(Aqb\*(Aq => $foo };
\&
\&        my $baz = clone( $bar );
\&
\&        print "\e$foo and \e$bar are different references\en" if ( $foo ne $bar );
\&        print "\e$foo\->{\*(Aqa\*(Aq} and \e$bar\->{\*(Aqa\*(Aq} are different references\en" if ( $foo\->{\*(Aqa\*(Aq} ne $bar\->{\*(Aqa\*(Aq} );
\&        print "\e$foo\->{\*(Aqa\*(Aq} and \e$foo\->{\*(Aqb\*(Aq} are the same, however\en" if ( $foo\->{\*(Aqa\*(Aq} eq $bar\->{\*(Aqb\*(Aq} );
.Ve
.PP
This makes sense, although this can be modified as well.  By using the internal variable, \s-1BREAK_REFS\s0, you
are also allowed to break internal references (may break up circular references, although won't fix
the circular reference in the originating reference).
.SH "PROGRAMATIC HOOKS"
.IX Header "PROGRAMATIC HOOKS"
Much like the Perl Storable module (available in all current Perl distributions), \f(CW\*(C`Clone::Fast\*(C'\fR allows for
hooks that will be accessed when cloning any object that has a hook defined.  This can be very handy where
Inside Out objects would not normally be cloned.  \s-1WHHAAATT\s0????  What I mean is, only the reference of an
object will be cloned, not the internal stash of the object.  Therefore, accessors that are defined within
an inside out object will not be cloned.  There is no real safe way to do this, with the exception of cloning
the entire class stash, breaking more things than it will fix.  Again, the reference of the object will be
fully cloned, and the object it's self will be a new reference, although it will be an empty object.  Subsiquently,
such as most inside out objects, the blessed reference is of a scalar type; an integer indicating the object id.
When cloning this, you would end up with two objects of the same type with the same object id.  The hooks
have been added in an attempt to prevent this from happening.
.SS "CLONEFAST_clone"
.IX Subsection "CLONEFAST_clone"
Again, much like Storable (though a little better, I hope), the function will be called *AFTER* the clone
operation has completed on the object being cloned.  The routine will have two scalar references passed
via the stack, representing both the cloned object as well as the source of the clone.  This *should* allow
for the programatic manipulation of the object before it gets returned to the caller, or placed into the
refering structure.
.PP
As an example, I will use the following object to define a 'hooked' object:
.PP
.Vb 1
\&        package Hookable;
\&
\&        use strict;
\&        use warnings;
\&
\&        use Clone::Fast qw( clone );
\&        
\&        sub new { bless {}, shift }
\&
\&        sub CLONEFAST_clone {
\&
\&                # Where clone is the cloned object from the source, where source
\&                # was the originating reference
\&                my ( $clone, $source ) = @_;
\&
\&                # I am going to pretend the source has a list of defined methods,
\&                # of which I want to clone and transfer to the clone; outside
\&                # of the blessed hash\-refrence that is the source of the object
\&                $clone\->$_( clone( $source\->$_() ) ) for ( qw( get_method_1 get_method_2 get_method_3 ) );
\&
\&                # At this point, the cloned object will also have a set of cloned
\&                # fields from the source.  If, by chance, any of the values of the
\&                # defined attribtes are other \*(AqHookable\*(Aq objects, the same routine
\&                # will be called on that object as well.
\&                
\&                # The API requires me to return the new $clone, this will be returned to
\&                # the caller
\&                return $clone;
\&        }
.Ve
.PP
Using the package from above, I will now use an example of a script where I will demonstrate how
the whole thing comes together:
.PP
.Vb 1
\&        #!/usr/bin/perl \-w
\&        
\&        use strict;
\&
\&        use Clone::Fast qw( clone );
\&
\&        my $hookable  = Hookable\->new();
\&        $hookable\->{\*(Aqhash_stuff\*(Aq} = \*(Aqsome value\*(Aq;
\&        
\&        my $structure = {
\&                \*(Aqhookable\*(Aq => $hookable,
\&                \*(Aqnew\*(Aq      => Hookable\->new(),
\&                \*(Aqdeeply\*(Aq   => {
\&                        \*(Aqhookable\*(Aq => $hookable,
\&                        \*(Aqnew\*(Aq      => Hookable\->new();
\&                },
\&        };
\&
\&        my $cloned = clone( $sturcture );
.Ve
.PP
This script will demonstrate a number of things.  1.) \f(CW\*(C`Clone::Fast::clone\*(C'\fR will, automagically call the hook
on all instances of the Hookable.  Though the hash_stuff key will automatically be cloned before the hook is ever
called.  Subsiquently, the hashes in both values of hookable in the hash will be references of one another, though
not references to the originating object.  The Hookable\->\fInew()\fR object, on the other hand, will not be referenced
to anything of the similar like.
.PP
As a secondary note, it was originally thought to allow for hooks to show up before and after the cloning of the
object.  Though, that would allow for the full change of the cloning type; this would be very bad.  Also, given
that it is somewhat reasonable to believe hooks will only be used with inside out objects, we can also assume the
cloning of a simple referent will be so lightweight that there will still be the benifit of having clone hook into
the object.  If anyone has beef with this paradigm, let me know and I'll change it.
.SH "CONFIGURATION VARIABLES"
.IX Header "CONFIGURATION VARIABLES"
.ie n .IP "$Clone::Fast::ALLOW_HOOKS" 4
.el .IP "\f(CW$Clone::Fast::ALLOW_HOOKS\fR" 4
.IX Item "$Clone::Fast::ALLOW_HOOKS"
The \f(CW\*(C`ALLOW_HOOKS\*(C'\fR variable will allow for the toggling behavior, telling \f(CW\*(C`Clone::Fast\*(C'\fR to check for
hooks when cloning objects.  (See \f(CW\*(C`PRGRAMATIC HOOKS\*(C'\fR for more details).  The varialble will default
to 'on', where \f(CW\*(C`Clone::Fast\*(C'\fR will always check each object for hooks defined within the object.
.Sp
.Vb 1
\&        use Clone::Fast qw( clone );
\&        
\&        $Clone::Fast::ALLOW_HOOKS = 1; # No need, this is default
\&
\&        my $object = HasHooks\->new();
\&
\&        package HasHooks;
\&
\&        use strict;
\&        use warnings;
\&
\&        sub new { bless {}, shift }
\&
\&        sub CLONEFAST_clone {
\&                my ( $clone, $source ) = @_;
\&
\&                # Re\-assigning the reference will now return the reference from the
\&                # C<Clone::Fast::clone> when cloning a HasHooks object, rather than
\&                # a cloned reference to the object.
\&                $clone = { \*(Aqobject\*(Aq => $clone };
\&                return $clone;
\&        }
.Ve
.ie n .IP "$Clone::Fast::BREAK_REFS" 4
.el .IP "\f(CW$Clone::Fast::BREAK_REFS\fR" 4
.IX Item "$Clone::Fast::BREAK_REFS"
.Vb 2
\&        use Clone::Fast qw( clone );
\&        $Clone::Fast::BREAK_REFS = 1;
\&
\&        my $foo = { \*(Aqa\*(Aq => \*(Aqb\*(Aq };
\&        my $bar = { \*(Aqa\*(Aq => $foo, \*(Aqb\*(Aq => $foo };
\&
\&        my $baz = clone( $bar );
\&
\&        print "\e$foo and \e$bar are different references\en" if ( $foo ne $bar );
\&        print "\e$foo\->{\*(Aqa\*(Aq} and \e$bar\->{\*(Aqa\*(Aq} are different references\en" if ( $foo\->{\*(Aqa\*(Aq} ne $bar\->{\*(Aqa\*(Aq} );
\&        print "\e$foo\->{\*(Aqa\*(Aq} and \e$foo\->{\*(Aqb\*(Aq} are no longer the same\en" if ( $foo\->{\*(Aqa\*(Aq} ne $bar\->{\*(Aqb\*(Aq} );
.Ve
.Sp
You will see that by adding the \s-1BREAK_REFS\s0 flag, you will change the overall behavior of the routine.
The \s-1BREAK_REFS\s0 flag must, simply, have truthfullness (as far as Perl is concerned) in order to be 'on'.
.Sp
Whereas:
.Sp
.Vb 1
\&        $Clone::Fast::BREAK_REFS = 1;
\&
\&        # Will do the same thing as:
\&        
\&        $Clone::Fast::BREAK_REFS = \*(Aqyes\*(Aq;
\&
\&        # Will do the same thing as:
\&        
\&        $Clone::Fast::BREAK_REFS = ( 2 != 1 );
.Ve
.Sp
Albeit handy, this feature may also slow down the module by some degree.  Therefore, there is some flexibility
into whether or not you need to use this, and the functionality can be compiled out of the object; speeding up
the cloning ability.  Therefore, Re-compiling the mdule without \s-1MINDFUL_REFS\s0 will increase the speed of the
module by a degree of 3x!  If you \s-1KNOW\s0 you will never use the \f(CW$Clone::Fast::BREAK_REFS\fR and are confident
with manually installing Perl modules from source, it is recommended you do so.  There are comments in the \s-1XS\s0 source
that will detail how to do this.
.Sp
This configuration only applies to the \f(CW\*(C`Clone::Fast::clone\*(C'\fR routine.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "Using Clone::Fast::clone" 4
.IX Item "Using Clone::Fast::clone"
\&\f(CW\*(C`Clone::Fast::clone\*(C'\fR is an exported routine.  You can either use it as such, or simply call it
directly on the package.
.Sp
Example w/ export:
.Sp
.Vb 1
\&        use Clone::Fast qw( clone );
\&
\&        my $source = { \*(Aqa\*(Aq => \*(Aqb\*(Aq };
\&        my $clone  = clone( $source );
.Ve
.Sp
Example w/o export
.Sp
.Vb 1
\&        use Clone::Fast;
\&
\&        my $source = { \*(Aqa\*(Aq => \*(Aqb\*(Aq };
\&        my $clone  = Clone::Fast::clone( $source );
.Ve
.IP "Using Clone::Fast::(is_)?circular" 4
.IX Item "Using Clone::Fast::(is_)?circular"
The \f(CW\*(C`Clone::Fast::(is_)?circular\*(C'\fR routines will allow you to test whether or not a structure
contains a ciruclar reference or not.
.SH "GOTCHAS/WARNINGS"
.IX Header "GOTCHAS/WARNINGS"
.IP "\fIbless()\fR'ed references (Perl objects)" 4
.IX Item "bless()'ed references (Perl objects)"
This module works great for blessed references, how ever the paradigm changes when trying to clone
inside out objects (or Conway's 'flywaight' style of object creation).  Clone does not, nor will not,
clone the stash of an object's class; this would break more than anything.  Given this, \s-1HOOKS\s0 have
been provided in order to programatically handle wierd stuff like this.  I am hoping applications,
developers and all of the like whom are using inside out objects will know what the heck it is I'm
talking about here.  There is a lot more information about this in the \s-1PROGRAMATIC\s0 \s-1HOOKS\s0 section.
.IP "ithreads" 4
.IX Item "ithreads"
I really have no idea how this will work in a treadded environment.  It should be \s-1OK\s0, but there is no
development that has taken this into account.
.IP "Hooks" 4
.IX Item "Hooks"
Hooks are pretty new, and may have some problems within them. Please, if you find anything you don't expect;
feel free to bug it and I will try to patch it up
\&\s-1ASAP\s0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Storable" 4
.IX Item "Storable"
This will, essentially, do the exact same thing as what this module does.  The difference being that Storable will
freeze the chunk of memory you are trying to clone, and thaw that binary chunk to another piece of memory.  This works
well, yet is very slow.  Subsiquently, Storable, as of Perl 5.8, is \s-1CORE\s0; and may be more trusted than this :)
.IP "Clone" 4
.IX Item "Clone"
The 'basis' of \f(CW\*(C`Clone::Fast\*(C'\fR, where Clone is simply a very optimized version of \f(CW\*(C`Clone::Fast\*(C'\fR.  Where hooks, some
exported routines and advanced functionality have been removed.
.IP "Clone::More" 4
.IX Item "Clone::More"
The counter-part and un-optimized version of Clone::Fast
.SH "AUTHOR"
.IX Header "AUTHOR"
Trevor Hall, <wazzuteke@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006 by Trevor Hall
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
